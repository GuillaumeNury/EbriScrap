import { Node } from "domhandler";

export enum ExtractTypes {
	HTML = 'html',
	OUTER_HTML = 'outerHtml',
	TEXT = 'text',
	PROP = 'prop',
	CSS = 'css',
}

export enum FormatTypes {
	STRING = 'string',
	ONE_LINE_STRING = 'one-line-string',
	HTML_TO_TEXT = 'html-to-text',
	NUMBER = 'number',
	URL = 'url',
	REGEX = 'regex',
	TRIM = 'trim',
}

export interface IPipe {
	name: string;
	args: string[];
}

export type ConfigTypes = IArrayConfig | IGroupConfig | IFieldConfig;

export class ArrayConfig<TData extends ConfigTypes = ConfigTypes>
	implements IArrayConfig {
	public containerSelector: string;
	public itemSelector: string;
	public data: TData;
	public includeSiblings?: boolean;
}

export interface IArrayConfig {
	containerSelector: string;
	itemSelector: string;
	includeSiblings?: boolean;
	data: ConfigTypes;
}

export class GroupConfig implements IGroupConfig {
	[key: string]: ConfigTypes;
}

export interface IGroupConfig {
	[key: string]: ConfigTypes;
}

export class FieldConfig implements IFieldConfig {
	public raw: string;
	public selector: string;
	public extractor: IPipe;
	public formators: IPipe[];
}

export interface IFieldConfig {
	raw: string;
	selector: string;
	extractor: IPipe;
	formators: IPipe[];
}

export interface IRawArrayConfig extends Array<IRawArrayConfigItem> {}

export interface IRawArrayConfigItem<T = any> {
	containerSelector: string;
	itemSelector: string;
	includeSiblings?: boolean;
	data: T;
}

export interface IRawGroupConfig {
	[key: string]: any;
}

export interface EbriscrapDebugStep {
	selectors: string[];
	path: string;
}

export interface DebugStep {
	nodes: Node[];
	config: ConfigTypes;
	path: string;
}

export interface EbriscrapDebugResult<T> {
	debug: EbriscrapDebugStep[];
	result: EbriScrapData<T>;
}

export type EbriScrapConfigArray<T> = IRawArrayConfigItem<EbriScrapConfig<T>>[];

export type EbriScrapConfigObject<T> = {
	[K in keyof T]: EbriScrapConfig<T[K]>
}

export type EbriScrapConfig<T = any> = T extends Array<any>
	? EbriScrapConfigArray<T[number]>
	: T extends object
		? EbriScrapConfigObject<T>
		: string;

export type EbriScrapDataArray<T> = T extends IRawArrayConfigItem<infer U>
	? EbriScrapData<U>
	: unknown;

export type EbriScrapData<T> =
	// Try to infer TArray
	T extends EbriScrapConfigArray<infer TArray>
		// If inferred as unknown, fallback on autogenerated type for array, else, return exact type (TArray)
		? (unknown extends TArray ? EbriScrapDataArray<T[number]>[] : TArray[])
		// If inferrence did not work but T is still an array
		: T extends Array<any>
			// Autogenerated type for array
			? EbriScrapDataArray<T[number]>[]
			// Same for objects, try to infer TObject
			: T extends EbriScrapConfigObject<infer TObject>
				// If any key has unknown type, fallback on autogenerated type for object, else, return exact type (TObject)
				? (unknown extends TObject[keyof TObject]
					? { [K in keyof T]: EbriScrapData<T[K]> }
					: TObject
				)
				// string | number | boolean
				: T;
